<!doctype html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <title>Vliegtuigen boven Arnhem</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Fonts à la RMarkdown -->
  <link href="https://fonts.googleapis.com/css2?family=Source+Serif+Pro:wght@400;600&family=Roboto+Mono&display=swap" rel="stylesheet">

  <!-- Leaflet CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
  />

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <style>
    body {
      font-family: "Source Serif Pro", serif;
      max-width: 900px;
      margin: 0 auto;
      padding: 2rem 1.5rem 3rem;
      line-height: 1.6;
      color: #222;
      background: #fafafa;
    }

    h1, h2, h3 {
      font-weight: 600;
      margin-top: 2.2rem;
      margin-bottom: 1rem;
    }

    h1 { font-size: 2.1rem; }
    h2 { font-size: 1.5rem; }
    h3 { font-size: 1.2rem; }

    p { margin: 0.6rem 0; }

    table {
      border-collapse: collapse;
      width: 100%;
      margin-top: 0.6rem;
      font-family: "Roboto Mono", monospace;
      font-size: 0.9rem;
      background: #fff;
    }

    th, td {
      border: 1px solid #ddd;
      padding: 0.35rem 0.5rem;
    }

    th {
      background: #f3f3f3;
      font-weight: 600;
    }

    .section {
      margin-top: 2rem;
      margin-bottom: 2.5rem;
      border-top: 1px solid #ddd;
      padding-top: 1.2rem;
    }

    #map {
      width: 100%;
      height: 350px;
      border: 1px solid #ccc;
      margin-top: 0.7rem;
    }

    /* Heatmap grid */
    #heatmap {
      margin-top: 0.7rem;
      font-size: 0.8rem;
      transform: scale(1.25);
      transform-origin: left top;
    }

    .heat-row {
      display: flex;
      align-items: center;
      margin-bottom: 2px;
    }
    .heat-label {
      width: 26px;
      text-align: right;
      margin-right: 4px;
      color: #555;
    }
    .heat-cell {
      width: 16px;
      height: 16px;
      margin-right: 2px;
      border-radius: 2px;
      background: transparent;
    }

    .note {
      font-size: 0.9rem;
      color: #555;
    }
  </style>
</head>
<body>

<h1>Vliegtuigen boven Arnhem</h1>
<p class="note">
  Deze pagina toont vluchtgegevens binnen een straal van circa 7,5 km rond Arnhem.
  De gegevens zijn afkomstig van <a href="https://adsb.fi" target="_blank">adsb.fi open data</a>
  en worden uitsluitend voor persoonlijk, niet-commercieel gebruik ingezet.
</p>
<p class="note">
  Met deze metingen wordt zichtbaar hoe vaak en wanneer er toestellen overkomen,
  welke routes worden gevlogen en welke vluchten structureel boven Arnhem plaatsvinden.
</p>

<!-- 1. Kaart en meetgebied -->
<div class="section">
  <h2>Het meetgebied boven Arnhem</h2>
  <p class="note">
    De rode cirkel geeft het gebied weer waarbinnen vluchten worden geregistreerd.
    De zwarte lijnen tonen de meest recente vluchten.
  </p>
  <div id="map"></div>
  <p class="note" id="map-updated"></p>
</div>

<!-- 2. Statistieken -->
<div class="section">
  <h2>Overzicht van de gemeten vluchten</h2>
  <p class="note">
    Dit overzicht vat de huidige dataset samen qua aantallen vluchten,
    duur van de meetperiode en dagelijkse drukte.
  </p>
  <div id="stats"></div>
</div>

<!-- 3. Uurlijkse drukte -->
<div class="section">
  <h2>Wanneer is het druk boven Arnhem?</h2>
  <p class="note">
    De onderstaande matrix laat per weekdag en uur zien hoe vaak er gemiddeld vluchten
    in het meetgebied worden geregistreerd. Donkere vakken duiden op relatief drukke momenten.
  </p>
  <div id="heatmap"></div>
</div>

<!-- 4. Vluchten per dag -->
<div class="section">
  <h2>Ontwikkeling van het aantal vluchten per dag</h2>
  <p class="note">
    Deze tijdreeks toont hoe het aantal vluchten per dag door de tijd heen varieert.
    Pieken en dalen kunnen samenhangen met vakantieperiodes, weersomstandigheden of
    wijzigingen in luchtverkeersroutes.
  </p>
  <canvas id="dailyChart" height="90"></canvas>
</div>

<!-- 5. Top callsigns -->
<div class="section">
  <h2>Meest voorkomende callsigns</h2>
  <p class="note">
    Sommige vluchten komen frequent terug boven Arnhem. Onderstaande tabel toont de
    callsigns welke het vaakst in het meetgebied geregistreerd zijn.
  </p>
  <table id="tbl-top">
    <thead>
      <tr><th>Callsign</th><th>Aantal keer</th></tr>
    </thead>
    <tbody></tbody>
  </table>
</div>

<!-- 6. Meest recente vluchten -->
<div class="section">
  <h2>Meest recente vluchten</h2>
  <p class="note">
    Deze tabel geeft de meest recente vluchten weer, waarbij per combinatie van
    callsign slechts de laatste meting wordt getoond.
  </p>
  <table id="tbl-last10">
    <thead>
      <tr>
        <th>Tijd</th>
        <th>Callsign</th>
        <th>Snelheid (km/h)</th>
        <th>Hoogte (km)</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>
</div>

<!-- 7. Histogram snelheden -->
<div class="section">
  <h2>Snelheidsverdeling van unieke vluchten</h2>
  <p class="note">
    Dit histogram toont de verdeling van grondsnelheden van unieke vluchten binnen het meetgebied.
  </p>
  <canvas id="speedHist" height="90"></canvas>
</div>

<!-- 8. Histogram hoogten -->
<div class="section">
  <h2>Hoogteverdeling van unieke vluchten</h2>
  <p class="note">
    Dit histogram laat zien op welke hoogtes toestellen doorgaans over Arnhem vliegen.
  </p>
  <canvas id="altHist" height="90"></canvas>
</div>

<!-- 9. Scatterplot snelheid vs. hoogte -->
<div class="section">
  <h2>Relatie tussen snelheid en hoogte</h2>
  <p class="note">
    Deze figuur toont per unieke vlucht de combinatie van grondsnelheid en hoogte
    op het moment dat het toestel binnen de meetcirkel is gemeten.
  </p>
  <canvas id="scatterSpeedAlt" height="90"></canvas>
</div>

<!-- Leaflet JS -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script>
const BACKEND = "https://arnhem-flights-api.onrender.com";

/* Helpers */
function kts_to_kmh(kts) {
  return kts ? (kts * 1.852).toFixed(1) : "";
}
function ft_to_km(ft) {
  return ft ? (ft * 0.0003048).toFixed(2) : "";
}
function to_amsterdam(iso) {
  if (!iso) return "";
  const dt = new Date(iso);
  return dt.toLocaleString("nl-NL", {
    timeZone: "Europe/Amsterdam",
    hour12: false
  }).replace(",", "");
}

/* ---- kaart timestamp ---- */
async function updateMapTimestamp() {
  try {
    const r = await fetch(BACKEND + "/api/last10");
    const data = await r.json();
    if (!data || data.length === 0) return;
    const human = to_amsterdam(data[0].ts);
    document.getElementById("map-updated").textContent =
      `Laatste update: ${human}`;
  } catch (e) {
    console.error("map timestamp error", e);
  }
}

/* last 10 flights */
async function loadLast10() {
  try {
    const r = await fetch(BACKEND + "/api/last10");
    const data = await r.json();
    const tbody = document.querySelector("#tbl-last10 tbody");
    tbody.innerHTML = "";
    data.forEach(row => {
      tbody.innerHTML += `
        <tr>
          <td>${to_amsterdam(row.ts)}</td>
          <td>${row.callsign}</td>
          <td>${kts_to_kmh(row.gs_kts)}</td>
          <td>${ft_to_km(row.alt_ft)}</td>
        </tr>`;
    });
  } catch (e) {
    console.error("last10 error", e);
  }
}

/* stats */
async function loadStats() {
  try {
    const r = await fetch(BACKEND + "/api/stats");
    const s = await r.json();
    document.getElementById("stats").innerHTML = `
      <p><strong>Totaal aantal vluchten:</strong> ${s.total_flights}</p>
      <p><strong>Eerste meting:</strong> ${to_amsterdam(s.first_ts)}</p>
      <p><strong>Laatste meting:</strong> ${to_amsterdam(s.last_ts)}</p>
      <p><strong>Aantal dagen met data:</strong> ${s.days}</p>
      <p><strong>Mediaan vluchten per dag:</strong> ${s.median_per_day}</p>
      <p><strong>Drukste dag:</strong> ${
        s.max_per_day_date ? `${s.max_per_day_date} (${s.max_per_day} vluchten)` : "–"
      }</p>`;
  } catch (e) {
    console.error("stats error", e);
  }
}

/* daily chart */
let dailyChart;
async function loadDailyChart() {
  try {
    const r = await fetch(BACKEND + "/api/daily_counts");
    const data = await r.json();
    const labels = data.map(d => d.day);
    const values = data.map(d => d.flights);

    const ctx = document.getElementById("dailyChart");
    if (dailyChart) dailyChart.destroy();
    dailyChart = new Chart(ctx, {
      type: "line",
      data: {
        labels,
        datasets: [{
          data: values,
          borderColor: "#444",
          borderWidth: 1.2,
          tension: 0.1,
          pointRadius: 0
        }]
      },
      options: {
        responsive: true,
        plugins: { legend: { display: false } },
        scales: {
          x: {
            title: { display: true, text: "Datum" }
          },
          y: {
            beginAtZero: true,
            title: { display: true, text: "Vluchten per dag" }
          }
        }
      }
    });
  } catch (e) {
    console.error("daily chart error", e);
  }
}

/* hourly heatmap */
async function loadHeatmap() {
  try {
    const r = await fetch(BACKEND + "/api/hourly_heatmap");
    const data = await r.json();

    const grid = Array.from({length:7},()=>Array(24).fill(0));
    let max = 0;
    data.forEach(row => {
      grid[row.dow][row.hour] = row.flights;
      if (row.flights > max) max = row.flights;
    });

    const weekdays = ["Zo","Ma","Di","Wo","Do","Vr","Za"];
    const container = document.getElementById("heatmap");
    container.innerHTML = "";

    // X-as: uren
    const hourRow = document.createElement("div");
    hourRow.className = "heat-row";
    hourRow.innerHTML = `<div class="heat-label"></div>`;
    for (let h=0; h<24; h++) {
      hourRow.innerHTML += `<div style="width:16px;text-align:center;font-size:0.7rem;color:#444">${h}</div>`;
    }
    container.appendChild(hourRow);

    // matrix zelf
    for (let dow=0; dow<7; dow++) {
      const rowDiv = document.createElement("div");
      rowDiv.className = "heat-row";
      rowDiv.innerHTML = `<div class="heat-label">${weekdays[dow]}</div>`;

      for (let h=0; h<24; h++) {
        const v = grid[dow][h];
        let col = "transparent";
        if (v > 0) {
          const t = v / max;
          col = `rgb(${Math.round(255*t)},0,${Math.round(255*(1-t))})`;
        }
        rowDiv.innerHTML += `<div class="heat-cell" style="background:${col}" title="${weekdays[dow]} ${h}:00 — ${v} vluchten"></div>`;
      }
      container.appendChild(rowDiv);
    }
  } catch (e) {
    console.error("heatmap error", e);
  }
}

/* top callsigns */
async function loadTop() {
  try {
    const r = await fetch(BACKEND + "/api/top_callsigns");
    const data = await r.json();
    const tbody = document.querySelector("#tbl-top tbody");
    tbody.innerHTML = "";
    data.forEach(row => {
      tbody.innerHTML += `<tr><td>${row.callsign}</td><td>${row.flights}</td></tr>`;
    });
  } catch (e) {
    console.error("top callsigns error", e);
  }
}

/* histogram speed */
let speedChart;
async function loadSpeedHist() {
  try {
    const r = await fetch(BACKEND + "/api/hist_speed");
    const raw = await r.json();

    // knots -> km/h
    const kmh = raw.map(k => k * 1.852).filter(v => v > 0);

    // buckets: 0–100, ..., 900–1000, 1000+
    const buckets = Array(11).fill(0);
    kmh.forEach(v => {
      if (v >= 1000) {
        buckets[10]++;  // 1000+
      } else if (v >= 0) {
        const idx = Math.floor(v / 100);
        buckets[idx]++;
      }
    });

    const labels = [
      "0–100","100–200","200–300","300–400","400–500",
      "500–600","600–700","700–800","800–900","900–1000","1000+"
    ];

    const ctx = document.getElementById("speedHist");
    if (speedChart) speedChart.destroy();

    speedChart = new Chart(ctx, {
      type: "bar",
      data: {
        labels,
        datasets: [{
          data: buckets,
          backgroundColor: "#777"
        }]
      },
      options: {
        responsive: true,
        plugins: { legend: { display: false } },
        scales: {
          x: {
            title: { display: true, text: "Snelheid (km/h)" }
          },
          y: {
            beginAtZero: true,
            title: { display: true, text: "Aantal observaties" }
          }
        }
      }
    });
  } catch (e) {
    console.error("speedHist error", e);
  }
}

/* histogram altitude */
let altChart;
async function loadAltHist() {
  try {
    const r = await fetch(BACKEND + "/api/hist_altitude");
    const raw = await r.json();

    // ft -> km
    const km = raw.map(ft => ft * 0.0003048).filter(v => v > 0);

    // buckets: 0–1, 1–2, ..., 13–14, 14+
    const buckets = Array(15).fill(0);
    km.forEach(v => {
      if (v >= 14) {
        buckets[14]++;     // 14+
      } else if (v >= 0) {
        const idx = Math.floor(v);   // 0 → 0–1, etc.
        buckets[idx]++;
      }
    });

    const labels = [
      "0–1","1–2","2–3","3–4","4–5","5–6","6–7",
      "7–8","8–9","9–10","10–11","11–12","12–13","13–14","14+"
    ];

    const ctx = document.getElementById("altHist");
    if (altChart) altChart.destroy();

    altChart = new Chart(ctx, {
      type: "bar",
      data: {
        labels,
        datasets: [{
          data: buckets,
          backgroundColor: "#777"
        }]
      },
      options: {
        responsive: true,
        plugins: { legend: { display: false } },
        scales: {
          x: {
            title: { display: true, text: "Hoogte (km)" }
          },
          y: {
            beginAtZero: true,
            title: { display: true, text: "Aantal observaties" }
          }
        }
      }
    });
  } catch (e) {
    console.error("altHist error", e);
  }
}

/* scatter speed vs altitude */
let scatterChart;
async function loadScatter() {
  try {
    const r = await fetch(BACKEND + "/api/scatter");
    const data = await r.json();

    // Expect each row: { gs_kts, alt_ft }
    const points = data
      .filter(d => d.gs_kts != null && d.alt_ft != null)
      .map(d => ({
        x: d.gs_kts * 1.852,           // knots → km/h
        y: d.alt_ft * 0.0003048        // ft → km
      }))
      .filter(p => p.x >= 0 && p.x <= 1000 && p.y >= 0 && p.y <= 14);

    const ctx = document.getElementById("scatterSpeedAlt");
    if (scatterChart) scatterChart.destroy();

    scatterChart = new Chart(ctx, {
      type: "scatter",
      data: {
        datasets: [{
          data: points,
          pointRadius: 2,
          pointHoverRadius: 3
        }]
      },
      options: {
        responsive: true,
        plugins: {
          legend: { display: false },
          tooltip: {
            callbacks: {
              label: (ctx) => {
                const x = ctx.parsed.x.toFixed(0);
                const y = ctx.parsed.y.toFixed(2);
                return ` ${x} km/h, ${y} km`;
              }
            }
          }
        },
        scales: {
          x: {
            type: "linear",
            min: 0,
            max: 1000,
            ticks: {
              stepSize: 100
            },
            title: {
              display: true,
              text: "Snelheid (km/h)"
            }
          },
          y: {
            type: "linear",
            min: 0,
            max: 14,
            ticks: {
              stepSize: 1
            },
            title: {
              display: true,
              text: "Hoogte (km)"
            }
          }
        }
      }
    });
  } catch (e) {
    console.error("scatter error", e);
  }
}

/* Map + tracks */
let map;
let trackLayers = [];

function initMap() {
  const center = [51.983333, 5.916667];

  map = L.map("map", {
    zoomControl: false,
    dragging: false,
    scrollWheelZoom: false,
    doubleClickZoom: false,
    boxZoom: false,
    keyboard: false,
    touchZoom: false,
    tap: false,
    inertia: false
  }).setView(center, 11);

  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    attribution: "&copy; OpenStreetMap-bijdragers"
  }).addTo(map);

  L.circle(center, {
    radius: 7500,
    color: "red",
    weight: 2,
    fillColor: "red",
    fillOpacity: 0.05
  }).addTo(map);
}

function clearTracks() {
  trackLayers.forEach(l => l.remove());
  trackLayers = [];
}

async function loadTracks() {
  try {
    if (!map) initMap();
    const r = await fetch(BACKEND + "/api/tracks");
    const data = await r.json();

    clearTracks();

    data.forEach(track => {
      const pts = track.points
        .filter(p => p.lat != null && p.lon != null)
        .map(p => [p.lat, p.lon]);

      if (pts.length < 2) return;

      const poly = L.polyline(pts, {
        color: "black",
        weight: 2,
        opacity: 0.9
      });

      poly.addTo(map).bindPopup(track.callsign);
      trackLayers.push(poly);
    });
  } catch (e) {
    console.error("tracks error", e);
  }
}

/* init calls */
loadStats();
loadHeatmap();
loadDailyChart();
loadTop();
loadLast10();
loadTracks();
loadSpeedHist();
loadAltHist();
loadScatter();
updateMapTimestamp();

/* periodic refresh */
setInterval(loadLast10, 60000);
setInterval(loadTracks, 120000);
setInterval(loadDailyChart, 300000);
setInterval(loadTop, 300000);
setInterval(updateMapTimestamp, 60000);
setInterval(loadSpeedHist, 300000);
setInterval(loadAltHist, 300000);
setInterval(loadScatter, 300000);
</script>

</body>
</html>
